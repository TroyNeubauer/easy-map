Implements # and adds a test to check for its correctness.

There could be another very subitle issue with the `compare_exchange_weak` variant and our Pointer trait.

With `compare_exchange` (strong) the outcome is binary:
a. The swap succeeded so `new` is now stored into (and owned exclusively) by the data structure
b. The swap failed, and the caller gets ownership of `new` back

With `compare_exchange_weak`, this gets a bit muddy:
a. The swap succeeded, this is reported back successfully
    so `new` is now stored into (and owned exclusively) by the data structure - easy

b. The swap failed, this is reported successfully
    the caller gets ownership of `new` back - easy

c. The swap actually succeeded, but the inner call to `std::sync::atomic::AtomicPtr::compare_exchange_weak` supriously fails:
    Imagine the following happens:
    0. The failure path runs, and `Box::from_raw` is called on `new` which is now, actually, in the datastructure
    1. The calling thread is now preempted by the OS for a while
    2. A different thread removes `new` and nievly retires it because its _no longer accessible_ right?
    3. There are no active hazard pointers to it currently, so it is dropped immediately 
    4. The origional thread comes alive again, holding a nucluear potato, a Box that think it owns freed memory


To be more rigerous, I believe the break in the safety chain that allows this is here:

Because `new` may be shared if the exchange spirrously failed.

Also this may not be a problem for `haphazard`, as the `haphazard::AtomicPtr` docs state:

But its a nice assumption to make when creating a data structure, because if the `haphazard::AtomicPtr` buckets in your concurrent hashmap don't own their pointees, who does?

I think we can fix this by simply checking if `compare_exchange_weak_ptr` failed but returned `current`.

Some questions:
1. Is this right for the semantics of std's `AtomicPtr::compare_exchange_weak`?
2. If we do this check for sperrious failure doesn't the semantics of `compare_exchange_weak` become the same as `compare_exchange` (we catch suprrious failures now)?

