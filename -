use std::{
    hash::{BuildHasher, BuildHasherDefault, Hasher},
    marker::PhantomData,
    sync::atomic::AtomicUsize,
};

use haphazard::AtomicPtr;

#[non_exhaustive]
struct Family;

struct Bucket<K, V> {
    key: K,
    value: V,
}

pub struct EasyMap<K, V, S: BuildHasher> {
    /// The hazard pointer domain for concurrent memory reclaimation
    domain: haphazard::Domain<Family>,

    /// The hasher used to determine indices
    build_hasher: S,

    /// The buckets of this hash map
    buckets: Box<[AtomicPtr<Bucket<K, V>, Family>]>,

    /// Stores the number of non-null nodes in buckets
    in_use: AtomicUsize,
}

impl<K, V, H: Hasher, S: BuildHasher> EasyMap<K, V, H, S> {
    pub fn new() -> Self {
        Self::with_capacity(32)
    }

    pub fn with_capacity(capacity: usize) -> Self {
        let mut buckets = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            let ptr = unsafe { AtomicPtr::new(std::ptr::null_mut()) };
            buckets.push(ptr);
        }

        Self {
            domain: haphazard::Domain::new(&Family),
            buckets: buckets.into_boxed_slice(),
            in_use: todo!(),
            build_hasher: S::,
            _h: PhantomData,
        }
    }

    pub fn insert(&self, key: K, value: V) -> Option<V> {}

    /// Returns the index of the bucket this key belongs to
    fn index_for_key(&self, key: &K) -> usize {
        self.hasher.write_
    }
}

#[cfg(test)]
mod tests {
    use crate::*;

    struct MyBuildHasher;

    impl BuildHasher for MyBuildHasher {
        type Hasher = ahash::RandomState;

        fn build_hasher(&self) -> Self::Hasher {
        todo!()
    }
    }

    #[test]
    fn feels_good() {
        let map = EasyMap::<&'static str, u32, MyBuildHasher>::new();
        map.insert("Troy", 5);
        map.insert("Jane", 15);
        map.insert("David", 20);

        assert_eq!(map.get("Troy"), Some(5));
        assert_eq!(map.get("Jane"), Some(15));
        assert_eq!(map.get("David"), Some(20));
    }
}
